---
title: "系统设计面试 101"
date: 2019-07-21T00:10:14+08:00
weight: 5
---

求职系列文章：

- [如何准备技术面试](../面试准备/)
- [如何写一份更好的简历](../如何写一份更好的简历/)
- [程序员国外求职指南](../程序员国外求职指南/)

在进行系统设计面试之前，我因为系统设计需要对整个项目所涉及的架构与解决方案有详尽的了解。例如当谈到负载均衡时，需要阐述使用 Http 的负载均衡还是 LVS 的，使用哪个软件的哪个负载均衡算法，优点缺点是什么，它们处理请求的流程，基础模型等等。但是经过大量的资料阅读，几次系统设计面试以及面试官反馈之后。我发现**系统设计的总体架构以及流程流程远比细节重要，短时间把所有技术细节都正确地分析到位非常困难，**把主要功能点与基本框架描述清楚，再就自己熟悉的方向深入作答，就能得到不错的评价。**这篇文章的目的并不是教你如何设计一套高可用的系统。而是让你在阅读完大量系统设计的学习资料之后，懂得如何在面试中表现出来。

#### 系统设计资源推荐
就像算法题中，了解基础的数据结构能够帮助我们快速解决问题，系统设计也需要我们了解一些常用的软件架构以及使用场景，这里我列出了一些学习资源，你可以先粗略看一遍。

- [Inside NGINX: How We Designed for Performance & Scale](https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/)
- [Introduction to Redis](https://redis.io/topics/introduction)
- [How does Hadoop work and how to use it?](https://www.dezyre.com/article/hadoop-explained-how-does-hadoop-work-and-how-to-use-it-/237)
- [Thorough Introduction to Apache Kafka](https://hackernoon.com/thorough-introduction-to-apache-kafka-6fbf2989bbc1)
- [Highscalability all time favorites](http://highscalability.com/all-time-favorites/) 
- [System design primer](https://github.com/donnemartin/system-design-primer)

#### 面试流程
系统设计总体可以分成 5个 部分，总时长约一个小时

1. 确定范围（5分钟）
2. 粗略计算（5分钟）
3. 系统架构（20分钟）
4. 分析瓶颈（10分钟）
5. 架构优化（10分钟）

#### 确定范围
系统面试开始之时，面试官可能会只提出一个问题：

> “如何设计像一个 Uber 这样的应用？”

或者

> “如何设计像一个 Whatsapp 这样的应用？”

这些问题一开始看起来很复杂，但是别紧张，面试官并不期待你可以在一小时内把 Uber 或者 Whatsapp 的全部功能设计出来。系统设计主要考核求职者在遇到一个抽象的问题时，如何通过分析以及推理把它转变成实际工程中能够解决的简单问题。**所以第一阶段，提问并确定范围就显得特别重要了。**，这里以设计 Uber 为例，Uber 包括很多功能，例如车辆预订，司机位置显示，费用支付，评价，日志分析等等。我们先把这些功能点列在白板：

![system_board_empty]()

接下来，我们从中选出一到两项主要功能以及自己比较熟悉的附加功能，在 Uber 中，车辆预订，司机信息这两个功能最为重要，是必选，再从剩下的选一项熟悉的，确定好之后与面试官进行确认：

![system_board]()

> “我先从几个功能开始进行设计可以吗？”

**我们必须经过面试官对功能点认可才能进行接下来的系统设计，可能需要根据面试官关注的功能点来做修改。**紧接着，我们需要确定功能点中，关键模块的每秒请求数量，数据存储量，两者的增长速度以及其他限制。接下来是第二个问题：

> “每秒有多少用户预订车辆？有多少数据需要存储？用户每个月的增长量是多少？对相应时间以及服务器数量有没有限制？”

运气好的话，面试官会助攻一把：“车辆预订系统每秒有 10000次 请求，每天有 100G 数据需要存储，用户每月增长 10%，服务器不能超过 20台。”，我们在感谢面试官之后把这些重要数据记录在白板。面试官也可能简单地回答“每天有 100万 人次使用车辆预订，需要存储每次预订的所有信息，包括订单号，起点，终点，路径经纬度等。”，这时候你就需要进入**粗略估算**环节：

#### 粗略估算
粗略估算是每名工程师都需要学习的技巧，把现有的数据转换成项目需要的数据。在例子中，每天有 100万人次车辆预订，我们可以假定每次预订发送两个请求，每天有 86400 秒，我们假定 80% 的请求出现在 20% 的时间中。也就是 5小时 18000秒 内需要处理 160万个 请求，平均 88res/s。再假设上下班时间请求数为峰值，约正常情况下的 300%，综合来说，车辆预订模块每秒需要处理 300个 请求。这个模块的吞吐率需要达到 300res/s。那么 300res/s 需要多少台服务器支撑呢？这个根据业务的复杂度不同有非常大的区别，尤其因为车辆预订设计了定价，派单等业务逻辑。为了给各位一个量化的标准，我引用了《构建高可用web站点》里的数据，注意，这里处理的是web请求，通常来说比较简单，所以吞吐量也会较高。

表格

我猜测我们单台服务器每秒能够处理 50次请求，在这个例子中，我们需要6台后端服务器来处理车辆预订。

#### 功能架构
我想大多数求职者都没有设计过 Uber，也没写过车辆预订的相应业务代码。但是没有关系，**系统设计应该跳脱于应用本身，而从功能点出发**，我们看看车辆预订功能到底做了什么。

1. 用户选择起点以及终点 -> 服务器返回定价以及预估路线。
2. 当用户点击车辆预订 -> 服务器开始派单并显示该司机信息，位置。

由于这个功能点是基于 HTTP 协议的，如果你有 Web 开发经验，会发现这些功能点与浏览器请求服务器的流程相似，虽然业务逻辑不同，但是都是客户端带参数请求服务端，服务端返回数据。我们可以把每个功能点理解成一个单独的 API 进行设计，首先，把车辆预订分为，定价，预估路线，派单，司机信息四个功能。最重要的是，8**在设计期间，你需要和面试官不断沟通，看他是否认可你的方案，根据他的提示来修改（面试官在面试前对题目的了解比我们要多，大多情况下跟着他不会错）。**

#### 定价
定价背后的逻辑比较复杂，主要是商业原因而不是技术原因，Uber 也一直在调整它的定价策略而达到利润最大化。我们可以先设计一个粗略的版本，首先，分析影响价格的因素，

| 因素        |
| ----------- |
| 路程长度    |
| 需求量（预约人数与周围司机数量比值）|
| 预订时间    |
| 地区消费水平|
| ...         |

这个表会包含非常多的因素，不过我们可以猜测里面最主要的三个因素以及它们的权重有以下的大小关系：

    W(路程长度) > W(需求量) > W(预约时间)

重复一次，这并不是真实的情况，只是我猜测的关系式，在系统设计阶段，可以随便猜。定价可能是通过一个公式计算出来：

    F(路程长度) * K(需求量) * G(预约时间)

其中，F，K，G函数分别对应一个哈希表，Uber 维护了每个因素与价格影响之间的哈希表，同样，我们可以假定如下：

| 距离        | 价格影响  |
| ----------- | ----------|
| 1-2公里     | 起步价 10 元  |
| 2公里以上   | 起步价格 + 每公里 2元  |
| **需求量**  |           |
| 1-2         | 1.2 倍    |
| 2-4         | 1.4 倍    |
| **预约时间**|           |
| 早晚高峰    | 1.2 倍    |
| 其他时间    | 1倍       |

一名用户在预约时，我们马上可以通过以上的公式计算出价格，例如用户在：

1. 目的地离起始点1.5公里
2. 附近2公里内有4名其他用户在预约，两名空闲司机（需求量为2）
3. 早高峰时段

预约车辆，那么预估价格为

10 * 1.4 * 1.2 = 16.8 元

这样看起来，一个粗略的定价功能就实现了，我们在白板中写下具体架构以及需要存储的数据。

![price_arch]()

![price_data]()

#### 预估路线
这是一个已经被解决的常见问题，我们可以把这个问题抽象为**如何快速找到有向无环图中两点的最短路径**，使用动态规划来解决。关键点在于把常见路线的预估路线存储起来，这样下次有类似请求的时候就不需要重复计算了。同样在白板中写下具体架构以及需要存储的数据：

![path_arch]()

![path_data]()

#### 派单
接收到预约请求之后，系统会派单给合适的司机，例如 2公里 内在线以及空闲的司机。这里有三个要点“2公里内”，“在线”，“空闲”，第一个和第三个比较容易，只需要在查询在线司机的时候附带筛选条件即可。我们需要在数据库中存储司机的信息。里面包含了

- 基本信息，包括车型，车牌，评分
- 最后在线时的经纬度
- 最后在线时的时间
- 现在是否空闲

我们根据最后在线时间，经纬度以及是否空闲先筛选出附近可用司机的列表，然后再根据司机的车型，评分加权得到排名，选出最合适的司机分配给用户。这几点中，判断司机是否在线比较麻烦。这个功能也很常见，像 Whatsapp 需要检测用户是否在线，在线的时候把之前收到的信息推送给用户。判断在线这个功能有两种方式实现，第一种解决方法最直观，司机客户端每分钟发送一个请求给服务器，在列表中我们维护着最近 X分钟 有发送此请求的司机。每当我们要找在线司机的时候，我们在列表中直接选即可。这个方法容易实现，不过缺点也很明显，第一是反馈不及时，司机可能因为网络原因 X分钟没请求服务器导致错过了派单，也可能司机下班了，但是系统在 X分钟 内依然派单过去。第二是需要处理更多的客户端请求，对系统的性能有影响。第二种解决方法是使用双向连接，例如 Websocket，服务器可以直接查询到客户端连接是否被关闭，每次用户连接服务器，服务器在列表中添加司机，一旦连接断了，则从列表中删除。同样在白板中写下具体架构以及需要存储的数据：

![dis_1]()

![dis_2]()


#### 司机信息
派单之后需要显示司机的实时位置，方向，
司机接单后就可以进行路径渲染了，这部分细节的难点非常多，例如滴滴使用的是FLP融合定位，在GPS有问题的时候，使用wifi，道路匹配，车辆航位推算因为要把车实时显示在正确的道路上，其中影响的因素有，这是道路吗？汽车的方向。简单来说是把司机的经纬度传到手机app端，手机进行分析以及渲染。具体细节如果你了解的话可以进行阐述。

![功能架构]()

#### 数据存储
我们之前有那么多数据，如何存储呢？
好吧，那么这里的数据怎么存储呢？服务器内存还是文件形式还是数据库，如果是数据库的话是 SQL 还是 NoSQL。这里的基本原则是，如果我们暂时不知道瓶颈在哪里的时候，但是数据又需要持久化存储，我们优先使用 SQL 数据库。我们现在可以将定价理解成一个 API 接口，手机应用发送出发点与终点的距离，当前的经纬度（用于给服务器计算需求量）以及当前时间给服务器，然后服务器就会返回价格。现阶段的架构如下

#### 整体架构

把这些功能点的架构合起来，
这时候，我们有一个简单的架构了，当然我们这里没有使用负载均衡或者应用层的缓存，如果你有架构经验的话，可以看到在应用服务器群前可以加一个负载均衡，让请求分发到不同的 API 服务器。不过这点在之后的分析瓶颈我们再加上就好。

#### 分析瓶颈
瓶颈结合我们一开始的数字，一台服务器够吗？当然不够，那么使用多少台，简单的计算。多台服务器如何分配任务？负载均衡。

#### 架构优化
现在我们得到这样的一张系统架构图，基本的设计模式如下，应用集群前加上负载均衡，关系型弱的数据使用NoSQL，计算耗时久的数据保存在NoSQL，所有工具都需要做集群（这里涉及一个问题，集群原理，集群失效如何恢复，可以参考文章最开始的链接学习，通常方法就两种，一种 failover，一种 沉鱼。关系型数据库做主从热备，然后写在主数据库，从数据库进行读。（阅读mysql 主从热备），那么最终我们可以得到这个架构图。

#### 互相沟通
和面试官交流
