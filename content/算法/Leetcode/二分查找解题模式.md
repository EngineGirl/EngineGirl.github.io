
---
title: "二分查找解题模式（未完成）"
date: 2019-07-01T00:10:14+08:00
---

#### 概述
二分查找是 Leetcode 常见的题型，难点主要有二，第一是编写正确的二分查找程序，过来人都知道，这一开始并不容易。第二是想到用二分查找来解这道题，这点比较难，因为要从题目中阅读到二分查找的必须条件，**从递增的有限区间，找到目标值或其索引。**

#### 辨别问题
我们仔细阅读下二分查找的必要条件：

> 从一个有限的递增区间种，找到目标值或其索引

像我说的这个看起来容易，但是不少题目往往不那么容易找到这个递增区间，常见的提示是

1. 题目要求的答案与数组的和有关
2. 数组都是正整数（二分查找的最小范围不会小于0）

这里有两个例子，你可以从中找下递增区间，相信可以慢慢找到感觉。

#### 解题模式
如果我们找到了递增区间，那么就可以开始编写二分查找的程序了，二分查找的程序有几种返回值

1. 查找目标元素是否在区间内
2. 查找目标元素插入的索引值（左边或者右边）
3. 查找区间内符合 **is_valid** 函数的最大值/最小值

我们先过一遍二分查找的程序，二分查找实现方式有多种，这里只要不混淆即可，里面有几个要注意的点，循环不变式：

在左边界以及右边界之间的递增区间中，找到目标值或其索引

这里面有几个容易犯错的地方


实现方式 | 右边界初始值 | 右边界是否可达 |左右边界能否相等 | 更新右边界  |
----     | ---------    | ----------     |-------          | -----       |
1       | 数组长度      | 不能           |不能             | 等于 mid    |
2       | 数组长度减一  | 可以           |可以             | 等于 mid - 1|

1. 右边界的范围
常见的实现方式中，右边界可以是数组长度（因为索引从零开始，所以不可达），也可以是数组长度减一（可达），
之后的几点都是间接地遵循这个初始条件。这里可以推理出，因为

右边界是数组长度->不可达->循环是找有效值，所以当左边界等于右边界的时候应该跳出循环。—>右边界更新的时候更新为mid而是mid-1（因为mid-1还没验证过，可能是结果）
以下的实现是形式1，同时注解中描述了两种形式都要注意的问题

    function binary_search(array, target):
        left = 0 or minimal val
        right = length of array
        while left < right:
            # 1. 根据题目要求，有时候会使用 left += (right-left)/2 的方式防止正整数移除，之后就把 left 当作 mid 即可。
            # 2. 我们找的目标值是整数还是浮点数来觉得是否使用整除。
            # Leetcode xxx 这里要对比的值是浮点数，就不能使用整除，而且之后 left 与 right 都应该更新为 mid，因为 mid + 1 有可能会错过正确答案
            mid = (left+right) / 2
            if array->mid equal to target:
                return mid
            else if array->mid < target:
                left = mid + 1
            else:
                right = mid


找目标值这个是最基础的二分查找，比较复杂的是找插入的索引值，或者查找数组中满足 is_valid 函数的值。这里举例：


Leetcode 778. Swim in Rising Water

